/*
  Copyright 2022 Adobe. All rights reserved.
  This file is licensed to you under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software distributed under
  the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
  OF ANY KIND, either express or implied. See the License for the specific language
  governing permissions and limitations under the License.
 */

package com.adobe.marketing.mobile;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * ConfigurationExtension module is responsible to retrieve the configuration for each module of the SDK, update
 * the shared state and output an event to the event hub that will contain these settings.
 *
 * <p>
 * ConfigurationExtension for the SDK can be obtained in following ways:
 * <ul>
 *     <li> Remote file hosted on Adobe servers associated with a unique application identifier generated by Launch UI. </li>
 *     <li> Local file bundled with device in folder with application read access. </li>
 *     <li> Programmatically by specifying specific configuration key/value to update. </li>
 * </ul>
 *
 * <p>
 * Each method will have their own public API, which customers can use to specify how and from where the configuration can be initialized.
 *
 * The ConfigurationExtension module listens for the following {@link Event}s:
 * <ol>
 *   <li>{@link EventType#CONFIGURATION} - {@link EventSource#REQUEST_CONTENT}</li>
 *   <li>{@code EventType.CONFIGURATION} - {@link EventSource#REQUEST_IDENTITY}</li>
 *   <li>{@link EventType#LIFECYCLE} - {@link EventSource#RESPONSE_CONTENT}</li>
 *	 <li>{@link EventType#HUB} - {@link EventSource#BOOTED}</li>
 *</ol>
 *
 * The ConfigurationExtension module dispatches the following {@code Event}s:
 * <ol>
 *   <li> {@code EventType.CONFIGURATION} - {@code EventSource.RESPONSE_CONTENT}</li>
 *   <li> {@code EventType.CONFIGURATION} - {@code EventSource.REQUEST_CONTENT}</li>
 *   <li> {@code EventType.CONFIGURATION} - {@link EventSource#RESPONSE_IDENTITY}</li>
 * </ol>
 *
 * The ConfigurationExtension module has dependencies on the following {@link PlatformServices}:
 * <ol>
 *   <li>{@link LocalStorageService}</li>
 *   <li>{@link JsonUtilityService}</li>
 *   <li>{@link NetworkService}</li>
 *   <li>{@link SystemInfoService}</li>
 * </ol>
 */
class ConfigurationExtension extends InternalModule {
	static final         String LOG_SOURCE                = ConfigurationExtension.class.getSimpleName();

	private static final String CONFIGURATION_URL_BASE    = "https://assets.adobedtm.com/%s.json";

	private static final String CONFIG_BUNDLED_FILE_NAME  = "ADBMobileConfig.json";
	private static final String CONFIG_MANIFEST_APPID_KEY = "ADBMobileAppID";
	private static final String CONFIG_REMOTE_SERVER	  = "com.adobe.marketing.mobile.RemoteConfigServer";

	private static final String DATASTORE_KEY               = "AdobeMobile_ConfigState";
	private static final String PERSISTED_OVERRIDDEN_CONFIG = "config.overridden.map";
	private static final String PERSISTED_APPID             = "config.appID";
	private static final String PERSISTED_RULES_URL         = "config.last.rules.url";

	private static final String RULES_CACHE_FOLDER          = "configRules";
	private static final String RULES_JSON_FILE_NAME        = "rules.json";
	private static final String RULES_JSON_KEY              = "rules";
	private static final String RULES_JSON_CONDITION_KEY    = "condition";
	private static final String RULES_JSON_CONSEQUENCES_KEY = "consequences";

	private static final int DEFAULT_NOT_DOWNLOAD_RULES_WITHIN_TIME_SEC = 15;
	static int NOT_DOWNLOAD_RULES_WITHIN_TIME_SEC = DEFAULT_NOT_DOWNLOAD_RULES_WITHIN_TIME_SEC;


	private final ConfigurationDispatcherConfigurationRequestContent  requestDispatcher;
	private final ConfigurationDispatcherConfigurationResponseContent  responseDispatcher;
	private final ConfigurationDispatcherConfigurationResponseIdentity  responseIdentityDispatcher;
	final ConcurrentLinkedQueue<Event> getsdkIdsEventQueue;
	private ConfigurationData            currentConfig;
	/// The persisted programmatic config or an empty config if none is found
	private ConfigurationData programmaticConfig;
	// The configuration without a merge from programmaticConfig, needed for clearing the config
	private ConfigurationData unmergedConfiguration;
	private boolean isUnregistered;
	private ConcurrentHashMap<String, Long> cachedRulesDownloadTime;
	final private List<Event> cachedEvents;
	private AtomicBoolean needToProcessEvents = new AtomicBoolean(true);

	private final ExecutorService rulesDownloadExecutor;
	/**
	 * Returns an instance of the ConfigurationExtension Module.  Adds a RequestContentListener to the provided EventHub
	 *
	 * @param eventHub an EventHub to be used by the module
	 * @param services an instance of PlatformServices to be used by the module
	 *
	 * @see EventHub
	 * @see PlatformServices
	 */
	public ConfigurationExtension(final EventHub eventHub, final PlatformServices services) {
		super(ConfigurationConstants.EventDataKeys.Configuration.MODULE_NAME, eventHub, services);
		getsdkIdsEventQueue = new ConcurrentLinkedQueue<Event>();
		cachedRulesDownloadTime = new ConcurrentHashMap<String, Long>();

		// register listeners
		registerListener(EventType.CONFIGURATION, EventSource.REQUEST_CONTENT, ConfigurationListenerRequestContent
						 .class);
		registerListener(EventType.HUB, EventSource.BOOTED, ConfigurationListenerBootEvent.class);
		registerListener(EventType.CONFIGURATION, EventSource.REQUEST_IDENTITY, ConfigurationListenerRequestIdentity.class);

		registerWildcardListener(ConfigurationWildCardListener.class);

		// create Dispatcher

		requestDispatcher = createRequestDispatcher();
		responseDispatcher = createResponseDispatcher();
		responseIdentityDispatcher = createResponseIdentityDispatcher();

		rulesDownloadExecutor = Executors.newSingleThreadExecutor();
		this.cachedEvents = Collections.synchronizedList(new ArrayList<Event>());
	}

	ConfigurationDispatcherConfigurationResponseIdentity createResponseIdentityDispatcher() {
		return createDispatcher(ConfigurationDispatcherConfigurationResponseIdentity.class);
	}

	ConfigurationDispatcherConfigurationRequestContent createRequestDispatcher() {
		return createDispatcher(ConfigurationDispatcherConfigurationRequestContent.class);
	}

	ConfigurationDispatcherConfigurationResponseContent createResponseDispatcher() {
		return createDispatcher(ConfigurationDispatcherConfigurationResponseContent.class);
	}

	// ========================================================
	// Event Handlers
	// ========================================================

	/**
	 * Handler for {@code EventType.CONFIGURATION} {@code EventSource.REQUEST_IDENTITY} {@code Event}.
	 * <p>
	 * This event is generated when the {@code getSDKIdentities} public API is called.
	 *
	 * <p>
	 * ConfigurationExtension module attempts to read all the identities known to the SDK. It then generates
	 * a {@code EventType.CONFIGURATION} {@code EventSource.RESPONSE_IDENTITY} response {@code Event} with all
	 * the obtained identities in a JSON {@code String} format.
	 *
	 * @param event An Configuration Request Identity event
	 * @see MobileIdentities
	 */
	void handleGetSdkIdentitiesEvent(final Event event) {
		getExecutor().execute(new Runnable() {
			@Override
			public void run() {
				getsdkIdsEventQueue.add(event);
				processGetSdkIdsEvent();
			}
		});
	}

	/**
	 * Handler for the Boot event created by EventHub.
	 *
	 * If AppId present, create a configureWithAppId request content event and then attempt to load configuration in the following
	 * order
	 * 1. cachedFile
	 * 2. Bundled
	 * 3. Overridden Config
	 *
	 * If No AppId, attempt to load the bundled/overridden configuration.
	 *
	 * @param event boot configuration event, which is generated when the module is initialized.
	 */
	void handleBootEvent(final Event event) {
		retrieveCachedRules(retrieveRulesURLFromPersistence());
		processBootEvent(event);
	}

	void handleWildcardEvent(final Event event) {
		this.cachedEvents.add(event);
	}

	/**
	 * Processes the Events generated by {@code getSDKIdentities} public API.
	 * <p>
	 * Calls the callback with empty {@code String} if {@link JsonUtilityService} is not available.
	 * Queues the {@link Event} in the {@link #getsdkIdsEventQueue} if the one of the requires shared state is in {@link EventHub#SHARED_STATE_PENDING}.
	 * Dispatches the paired {@code EventType.CONFIGURATION}, {@code EventSource.RESPONSE_IDENTITY} event into the {@link EventHub}
	 * with {@link String} identities JSON.
	 */
	void processGetSdkIdsEvent() {
		while (!getsdkIdsEventQueue.isEmpty()) {
			final Event event = getsdkIdsEventQueue.peek();


			// check if jsonUtility service is available to process the event.
			// If unavailable call the callback with empty string and remove the event from the queue
			JsonUtilityService jsonUtilityService = getJSONUtilityService();

			if (jsonUtilityService == null) {
				Log.debug(LOG_SOURCE, "%s (JSON Utility Service), unable to retrieve sdk identities", Log.UNEXPECTED_NULL_VALUE);
				responseIdentityDispatcher.dispatchAllIdentities("{}", event.getResponsePairID());
				getsdkIdsEventQueue.poll();
				continue;
			}

			// verify that if all the required shared state is not in pending.
			// If not, break out of the loop and wait for the shared state update event to happen.
			if (!MobileIdentities.areAllSharedStatesReady(event, this)) {
				break;
			}

			final String allIds = MobileIdentities.getAllIdentifiers(jsonUtilityService, event, this);
			responseIdentityDispatcher.dispatchAllIdentities(allIds, event.getResponsePairID());

			getsdkIdsEventQueue.poll();
		}
	}

	private void processBootEvent(final Event event) {
		Log.trace(ConfigurationExtension.LOG_SOURCE, "Processing boot configuration event");

		// programmed config from the persistence
		retrieveProgrammaticConfigFromPersistence();

		String appId = getValidAppID();

		// If appID is present from any source.
		if (!StringUtils.isNullOrEmpty(appId)) {

			// dispatch an configureWithAppID internal event if we have a valid appId(From manifest or persistence).
			// We dispatch this during initialization just to prevent other configureWithAppId calls occurring before this event.
			requestDispatcher.dispatchInternalConfigureWithAppIdEvent(appId);

			// Create a shared state with cached config, if present
			if (loadCachedConfig(appId, event)) {
				return;
			}
		}

		// If the app is not configured with an AppID (OR) if the cachedConfig for the appID is missing
		// attempt to load the bundled configuration
		if (loadBundledConfig(event, CONFIG_BUNDLED_FILE_NAME)) {
			return;
		}

		// If the application is not configured with an AppID and has no bundled configuration.
		// Just load the programmatic config
		if (loadProgrammaticConfig(event)) {
			return;
		}
	}

	/**
	 * Unpacks the configuration request content event and processes them according to their event data key.
	 *
	 * @param event a configuration request content event.
	 */
	void handleEvent(final Event event) {
		Log.trace(ConfigurationExtension.LOG_SOURCE, "Handling the configuration event: %s", event.getEventNumber());
		EventData eventData = event.getData();

		// if the event has an app id. try to fetch from the remote
		if (eventData.containsKey(
					ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_JSON_APP_ID)) {
			getExecutor().execute(new Runnable() {
				@Override
				public void run() {
					processConfigureWithAppIDEvent(event);
				}
			});
		}
		// if the event has a path to a file in asset folder, try to load configuration from the file
		else if (eventData.containsKey(
					 ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_JSON_ASSET_FILE)) {
			getExecutor().execute(new Runnable() {
				@Override
				public void run() {

					final String fileName = event.getData().optString(
												ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_JSON_ASSET_FILE, null);

					loadBundledConfig(event, fileName);
				}
			});
		}
		// if the event has a path to a file, try to load configuration from the file
		else if (eventData.containsKey(
					 ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_JSON_FILE_PATH)) {
			getExecutor().execute(new Runnable() {
				@Override
				public void run() {
					processConfigWithFilePathEvent(event);
				}
			});
		}
		// if the event has a manually configured information, try to override with existing configuration
		else if (event.getData().containsKey(
					 ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_UPDATE_CONFIG)) {
			getExecutor().execute(new Runnable() {
				@Override
				public void run() {
					processUpdateConfigEvent(event);
				}
			});


		} else if (event.getData().containsKey(
					   ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_CLEAR_UPDATED_CONFIG)) {
			getExecutor().execute(new Runnable() {
				@Override
				public void run() {
					processClearUpdatedConfigEvent(event);
				}
			});
		} else if (event.getData().containsKey(
					   ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_RETRIEVE_CONFIG)) {
			// do not create shared state here, this is just a request for information
			getExecutor().execute(new Runnable() {
				@Override
				public void run() {
					processPublishConfigurationEvent(event);
				}
			});
		}

	}

	/**
	 * Attempts to load a configuration from the provide file path
	 *
	 * @param event    event which triggered the configuration request
	 */
	void processConfigWithFilePathEvent(final Event event) {
		final String filePath = event.getData().optString(
									ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_JSON_FILE_PATH, null);

		// make sure our filePath is valid
		if (StringUtils.isNullOrEmpty(filePath)) {
			Log.warning(ConfigurationExtension.LOG_SOURCE,
						"Unable to read config from provided file (filePath is invalid)");
			return;
		}

		Log.trace(ConfigurationExtension.LOG_SOURCE, "Processing configWithFilePath Event. \n %s", filePath);
		final String jsonConfigString = FileUtil.readStringFromFile(new File(filePath));

		Log.trace(ConfigurationExtension.LOG_SOURCE, "Configuration obtained from filePath %s is \n %s", filePath,
				  jsonConfigString);
		configureWithJsonString(jsonConfigString, event, true); // state already created with null data

	}

	/**
	 * Unpacks the update configuration request content event. The newConfiguration data is added over the existing
	 * configuration and a Configuration response event is created.
	 *
	 * @param event an update Configuration event.
	 */
	@SuppressWarnings("unchecked")
	void processUpdateConfigEvent(final Event event) {
		// update the programmaticConfig with the new config from API and persist them in disk
		Map<String, Variant> newProgrammaticConfig = event.getData().optVariantMap(
					ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_UPDATE_CONFIG, null);

		// if update config is not provided or is empty, abort update config request.
		if (newProgrammaticConfig == null || newProgrammaticConfig.isEmpty()) {
			Log.debug(LOG_SOURCE, "Configuration update data was either not provided in event or is empty.");
			return;
		}

		Log.trace(ConfigurationExtension.LOG_SOURCE, "Processing updateConfiguration Event. \n %s", newProgrammaticConfig);
		// Retrieve the latest programmatic config value from the persistence.
		retrieveProgrammaticConfigFromPersistence();

		programmaticConfig.put(newProgrammaticConfig);

		saveProgrammaticConfigToPersistence(programmaticConfig);

		if (currentConfig == null) {
			if (getJSONUtilityService() == null) {
				return;
			}

			currentConfig = new ConfigurationData(getJSONUtilityService());
		}

		currentConfig.put(programmaticConfig);

		changeConfiguration(event, currentConfig, true);
	}

	void processClearUpdatedConfigEvent(final Event event) {
		Log.trace(ConfigurationExtension.LOG_SOURCE, "Processing clear updated configuration event");

		if (unmergedConfiguration == null) {
			if (getJSONUtilityService() == null) {
				return;
			}

			unmergedConfiguration = new ConfigurationData(getJSONUtilityService());
		}

		// remove overridden configuration from persistence
		removeProgrammaticConfigFromPersistence();

		// clear value stored in programmaticConfig variable
		retrieveProgrammaticConfigFromPersistence();

		// set currentConfig value to unmergedConfig
		currentConfig = unmergedConfiguration;

		// Update the shared state and dispatch a event clearing updated configuration
		changeConfiguration(event, unmergedConfiguration, true);
	}

	/**
	 * Process the configuration request content events with appId. Tries to retrieve the latest configuration
	 * from the remote.
	 *
	 * @param event    the configureWithAppIDEvent
	 */
	void processConfigureWithAppIDEvent(final Event event) {
		final EventData eventData = event.getData();

		if (eventData == null) {
			Log.trace(LOG_SOURCE, "%s (event data), for ConfigureWithAppID event, Ignoring event", Log.UNEXPECTED_NULL_VALUE);
			return;
		}

		final String newAppId = event.getData().getString(
									ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_JSON_APP_ID);

		if (StringUtils.isNullOrEmpty(newAppId)) {
			Log.trace(LOG_SOURCE, "App ID was null or empty while processing ConfigureWithAppID event");
			removeAppIdFromPersistence();
			return;
		}

		if (!validateForInternalEventAppIDChange(eventData, newAppId)) {
			Log.trace(LOG_SOURCE, "App ID is changed. Ignoring the setAppID Internal event %s", newAppId);
			return;
		}

		Log.trace(ConfigurationExtension.LOG_SOURCE, "Processing configureWithAppID event. AppID -(%s)", newAppId);
		saveAppIdToPersistence(newAppId);

		// get a downloader instance
		ConfigurationDownloader configurationDownloader = getConfigDownloader(newAppId);

		if (configurationDownloader == null) {
			Log.trace(LOG_SOURCE, "%s (Configuration Downloader).", Log.UNEXPECTED_NULL_VALUE);
			return;
		}

		// first, just blindly try to download the config
		String jsonString = configurationDownloader.downloadConfig();

		if (StringUtils.isNullOrEmpty(jsonString)) {
			// download failed
			// try to get a cached config
			jsonString = configurationDownloader.loadCachedConfig();
		}

		if (StringUtils.isNullOrEmpty(jsonString)) {
			// no cached config
			// if the network is down, wait for it to come back up
			final PlatformServices platformServices = getPlatformServices();
			final SystemInfoService systemInfoService = platformServices == null ? null : platformServices.getSystemInfoService();
			final boolean networkIsDown = (
											  systemInfoService != null &&
											  systemInfoService.getNetworkConnectionStatus() != SystemInfoService.ConnectionStatus.CONNECTED);

			if (networkIsDown && waitForNetworkConnection()) {
				// try once more after network is back up
				jsonString = configurationDownloader.downloadConfig();
			}
		}

		if (StringUtils.isNullOrEmpty(jsonString)) {
			Log.warning(LOG_SOURCE, "Unable to fetch config. Rolling back to previous configuration.");
			return;
		}


		// Update the shared state and dispatch a event with the received jsonString.
		configureWithJsonString(jsonString, event, true);
	}

	boolean waitForNetworkConnection() {
		final int WAIT_FOR_NETWORK_POLL_MS = 1000;
		final PlatformServices platformServices = getPlatformServices();

		if (platformServices == null) {
			return false;
		}

		final SystemInfoService systemInfoService = platformServices.getSystemInfoService();

		if (systemInfoService == null) {
			return false;
		}

		class State extends Object {
			public boolean isListenerRegistered = false;
		};

		final State state = new State();

		while (true) {
			synchronized (this) {
				if (isUnregistered) {
					return false;
				}
			}

			final SystemInfoService.ConnectionStatus connectionStatus = systemInfoService.getNetworkConnectionStatus();

			if (connectionStatus == SystemInfoService.ConnectionStatus.CONNECTED) {
				return true;
			}

			// DISCONNECTED

			synchronized (state) {
				if (!state.isListenerRegistered) {
					state.isListenerRegistered = true;
					systemInfoService.registerOneTimeNetworkConnectionActiveListener(new
					SystemInfoService.NetworkConnectionActiveListener() {
						@Override
						public final void onActive() {
							synchronized (state) {
								state.notifyAll();
								state.isListenerRegistered = false;
							}
						}
					});
				}

				try {
					state.wait(WAIT_FOR_NETWORK_POLL_MS);
				} catch (final InterruptedException e) {
					continue;
				}
			}
		}
	}

	@Override
	protected void onUnregistered() {
		synchronized (this) {
			isUnregistered = true;
		}
	}

	/**
	 * Retrieves current configuration through a new configuration response event.
	 *
	 * @param event the publish configuration event
	 */
	void processPublishConfigurationEvent(final Event event) {
		Log.trace(ConfigurationExtension.LOG_SOURCE, "Processing publish configuration event");


		if (getJSONUtilityService() == null) {
			return;
		}

		ConfigurationData newConfigData = new ConfigurationData(getJSONUtilityService())
		.put(currentConfig).put(programmaticConfig);

		responseDispatcher.dispatchConfigResponseWithEventData(newConfigData.getEventData(),
				event.getResponsePairID());
	}

	/**
	 * Dispatches a ConfigurationResponseContent event with the provided JSON string.
	 * Overrides with the programmed configuration if they exist.
	 *
	 * @param jsonConfigString a String containing the JSON configuration
	 * @param event            event which triggered the configuration request
	 * @param loadRules         if set to true, will try to load the remote rules
	 */
	void configureWithJsonString(final String jsonConfigString,
								 final Event event,
								 final boolean loadRules) {

		if (getJSONUtilityService() == null) {
			return;
		}

		// Convert the JSONString into an EventData and save it in memory
		ConfigurationData newConfig = new ConfigurationData(getJSONUtilityService())
		.put(jsonConfigString);

		if (newConfig.isEmpty()) {
			Log.debug(LOG_SOURCE, "Empty configuration found when processing JSON string.");
			return;
		}

		retrieveProgrammaticConfigFromPersistence();

		unmergedConfiguration = new ConfigurationData(getJSONUtilityService()).put(jsonConfigString);
		currentConfig = newConfig;

		// Before dispatching override the primary configuration with the programmatic configuration.
		currentConfig.put(programmaticConfig);

		changeConfiguration(event, currentConfig, loadRules);

	}


	// ========================================================
	// Other Helper Methods
	// ========================================================

	/**
	 * Performs modifications to configuration
	 *
	 * @param triggerEvent {@code Event} that the configuration change should be valid for
	 * @param configurationData {@code ConfigurationData} object containing the new configuration
	 * @param loadRules {@code boolean} if we should load the rules
	 */
	private void changeConfiguration(final Event triggerEvent, final ConfigurationData configurationData,
									 final boolean loadRules) {
		final EventData configEventData = configurationData.getEventData();


		createSharedState(triggerEvent.getEventNumber(), configEventData);
		Log.trace(LOG_SOURCE, "Shared state is created for event number %d with data \n %s", triggerEvent.getEventNumber(),
				  configEventData);

		if (loadRules) {
			final String remoteRulesURL = configurationData.getEventData().optString(
											  ConfigurationConstants.EventDataKeys.Configuration.RULES_CONFIG_URL, "");
			this.rulesDownloadExecutor.execute(new Runnable() {
				@Override
				public void run() {
					downloadRules(remoteRulesURL);
				}
			});
		}

		responseDispatcher.dispatchConfigResponseWithEventData(configEventData, triggerEvent.getPairID());
	}

	/**
	 * Sort the preference and returns the valid app Id used
	 *
	 * @return {@code String} application identifier
	 */
	private String getValidAppID() {
		// return the persisted appId if we have
		String appId = retrieveAppIdFromPersistence();

		if (!StringUtils.isNullOrEmpty(appId)) {
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Valid AppID is retrieved from persistence - %s", appId);
			return appId;
		}

		// else try to fetch the appID from manifest
		return getAppIDFromManifest();
	}

	/**
	 * Attempts to configure with the bundled configuration.
	 *
	 * @param event event which triggered the configruation request.
	 * @param fileName the name of the asset file
	 *
	 * @return {@code boolean} true if the configuration is successfully loaded, false otherwise
	 */
	protected boolean loadBundledConfig(final Event event, final String fileName) {
		String bundledConfigContent = readContentFromAsset(fileName);

		if (bundledConfigContent == null) {
			Log.trace(ConfigurationExtension.LOG_SOURCE, "%s (Failed to read bundled config file content from asset file %s)",
					  Log.UNEXPECTED_NULL_VALUE, fileName);
			return false;
		}

		Log.debug(ConfigurationExtension.LOG_SOURCE, "Bundled configuration loaded from asset file (%s). \n %s", fileName,
				  bundledConfigContent);
		configureWithJsonString(bundledConfigContent, event, true);
		return true;
	}


	/**
	 * Attempts to configure with the cached file.
	 *
	 * @param appID associated appID of that cache file.
	 * @param event event which triggered the configruation request.
	 *
	 * @return {@code boolean} true if the cached file is successfully loaded, false otherwise
	 */
	private boolean loadCachedConfig(final String appID, final Event event) {
		ConfigurationDownloader configurationDownloader = getConfigDownloader(appID);

		if (configurationDownloader == null) {
			return false;
		}

		String cachedConfigJSON = configurationDownloader.loadCachedConfig();

		if (StringUtils.isNullOrEmpty(cachedConfigJSON)) {
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Nothing is loaded from cached file");
			return false;
		}

		Log.debug(ConfigurationExtension.LOG_SOURCE, "Cached configuration loaded. \n %s", cachedConfigJSON);
		configureWithJsonString(cachedConfigJSON, event, false);
		return true;

	}

	/**
	 * Attempts to configure with the programmatic configuration.
	 *
	 * @param event event which triggered the configuration request.
	 *
	 * @return {@code boolean} true if succeeded, false otherwise
	 */
	private boolean loadProgrammaticConfig(final Event event) {
		if (programmaticConfig.isEmpty()) {
			return false;
		}

		changeConfiguration(event, programmaticConfig, true);
		return true;
	}


	/**
	 * Provides you the instance of the configuration downloader with the specified url.
	 *
	 * @param appId the appID required to build the url for the downloader.
	 *
	 * @return {@code ConfigurationDownloader} configuration downloader instance, or null if an error occurs
	 * attempting to create the ConfigurationDownloader instance.
	 */
	ConfigurationDownloader getConfigDownloader(final String appId) {

		if (getPlatformServices() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Platform services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		if (getPlatformServices().getSystemInfoService() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (System Info services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		// check whether manifest overrides the config endpoint
		String requestUrlString = String.format(CONFIGURATION_URL_BASE, appId);
		final SystemInfoService systemInfoService = getPlatformServices().getSystemInfoService();

		if (systemInfoService != null) {
			String remoteConfigServer = systemInfoService.getProperty(CONFIG_REMOTE_SERVER);

			if (!StringUtils.isNullOrEmpty(remoteConfigServer)) {
				requestUrlString = String.format(remoteConfigServer, appId);
			}
		}

		if (getPlatformServices().getNetworkService() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Network services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		// Build a Configuration Downloader
		try {
			return new ConfigurationDownloader(getPlatformServices().getNetworkService(),
											   getPlatformServices().getSystemInfoService(), requestUrlString);
		} catch (MissingPlatformServicesException exp) {
			Log.warning(LOG_SOURCE, "Unable to Initialize Downloader (%s)", exp);
			return null;
		}
	}

	// ========================================================
	// Platform resource getters
	// ========================================================

	/**
	 * Reads the AppId from the manifest file.
	 * Returns null if appId is not found.
	 *
	 * @return {@code String} application identifier from manifest file
	 */
	private String getAppIDFromManifest() {

		if (getPlatformServices() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Platform services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		if (getPlatformServices().getSystemInfoService() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (System Info services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		final SystemInfoService systemInfoService = getPlatformServices().getSystemInfoService();

		if (systemInfoService == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE,
					  "%s (System info service), unable to read AppID from manifest", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		final String manifestAppId = systemInfoService.getProperty(CONFIG_MANIFEST_APPID_KEY);

		if (StringUtils.isNullOrEmpty(manifestAppId)) {
			return null;
		}

		Log.trace(ConfigurationExtension.LOG_SOURCE, " Valid AppID is retrieved from manifest - %s", manifestAppId);
		saveAppIdToPersistence(manifestAppId);
		return manifestAppId;
	}


	/**
	 * Reads the bundled ADBMobileConfig.json file from the assets folder.
	 * Returns null if the Bundled file is not found.
	 *
	 * @return {@code String} bundled file content
	 */
	private String readContentFromAsset(final String fileName) {
		if (StringUtils.isNullOrEmpty(fileName)) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "Invalid asset file name.");
			return null;
		}

		if (getPlatformServices() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Platform services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		final SystemInfoService systemInfoService = getPlatformServices().getSystemInfoService();

		if (systemInfoService == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (System info services), unable to read bundled configuration",
					  Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		final InputStream configStream = systemInfoService.getAsset(fileName);

		if (configStream == null) {
			return null;
		}

		return StringUtils.streamToString(configStream);
	}

	// ========================================================
	// private methods
	// ========================================================


	/**
	 * Load the overriddenConfiguration from persistent storage.
	 */
	private void retrieveProgrammaticConfigFromPersistence() {

		if (getJSONUtilityService() == null) {
			return;
		}

		this.programmaticConfig = new ConfigurationData(getJSONUtilityService());
		LocalStorageService.DataStore configStore = getDataStore();

		if (configStore != null) {
			String jsonString = configStore.getString(PERSISTED_OVERRIDDEN_CONFIG, null);
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Loading overridden configuration from persistence - \n %s", jsonString);
			this.programmaticConfig = new ConfigurationData(getJSONUtilityService()).put(jsonString);
		} else {
			Log.debug(ConfigurationExtension.LOG_SOURCE,
					  "%s (Local storage service), unable to load overridden config from persistence", Log.UNEXPECTED_NULL_VALUE);
		}
	}


	/**
	 * Saves the overriddenConfig map in the persistence under the Configuration DataStore.
	 * Used to persist the programmed Configuration between launches
	 *
	 * @param overriddenConfig new overriddenConfig map that needs to be saved
	 */
	private void saveProgrammaticConfigToPersistence(final ConfigurationData overriddenConfig) {
		LocalStorageService.DataStore configStore = getDataStore();

		if (configStore != null) {
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Saving the overridden configuration to persistence - \n %s",
					  overriddenConfig);
			configStore.setString(PERSISTED_OVERRIDDEN_CONFIG, overriddenConfig.getJSONString());
		} else {
			Log.debug(ConfigurationExtension.LOG_SOURCE,
					  "%s (Local storage service), unable to save overridden config to persistence", Log.UNEXPECTED_NULL_VALUE);
		}
	}

	/**
	 * Removes the overriddenConfig map from the persistence under the Configuration Datastore
	 */
	private void removeProgrammaticConfigFromPersistence() {
		LocalStorageService.DataStore configStore = getDataStore();

		if (configStore != null) {
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Removing overridden configuration from persistence");
			configStore.remove(PERSISTED_OVERRIDDEN_CONFIG);
		} else {
			Log.debug(ConfigurationExtension.LOG_SOURCE,
					  "%s (Storage Service), unable to remove overridden configuration from persistence",
					  Log.UNEXPECTED_NULL_VALUE);
		}
	}



	/**
	 * Load the appId from persistent storage.
	 *
	 * @return {@code String} application identifier from persistence, or null
	 */
	private String retrieveAppIdFromPersistence() {
		LocalStorageService.DataStore configStore = getDataStore();

		if (configStore != null) {
			final String persistedAppID = configStore.getString(PERSISTED_APPID, null);
			Log.trace(ConfigurationExtension.LOG_SOURCE, "AppID loaded from persistence - %s", persistedAppID);
			return persistedAppID;
		} else {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Storage Service), unable to load appId from persistence",
					  Log.UNEXPECTED_NULL_VALUE);
			return null;
		}
	}


	/**
	 * Saves the appID in the persistence under the Configuration DataStore.
	 * Used to persist the appID between launches to load the cached configuration.
	 *
	 * @param appID appID that needs to be saved
	 */
	private void saveAppIdToPersistence(final String appID) {
		LocalStorageService.DataStore configStore = getDataStore();

		if (configStore != null) {
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Saving appID to persistence - %s", appID);
			configStore.setString(PERSISTED_APPID, appID);
		} else {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Storage Service), unable to save appId to persistence",
					  Log.UNEXPECTED_NULL_VALUE);
		}
	}

	/**
	 * Removes the appId from the persistence under the Configuration Datastore
	 */
	private void removeAppIdFromPersistence() {
		LocalStorageService.DataStore configStore = getDataStore();

		if (configStore != null) {
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Removing appID from persistence");
			configStore.remove(PERSISTED_APPID);
		} else {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Storage Service), unable to remove appId from persistence",
					  Log.UNEXPECTED_NULL_VALUE);
		}
	}

	/**
	 * Load the last known rules URL from persistent storage.
	 *
	 * @return {@code String} last known rules URL from persistence, or null
	 */
	private String retrieveRulesURLFromPersistence() {
		LocalStorageService.DataStore configStore = getDataStore();

		if (configStore != null) {
			final String persistedRulesUrl = configStore.getString(PERSISTED_RULES_URL, null);
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Last known rules URL loaded from persistence - %s", persistedRulesUrl);
			return persistedRulesUrl;
		} else {
			Log.debug(ConfigurationExtension.LOG_SOURCE,
					  "%s (Storage Service), unable to load the last known rules URL from persistence", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}
	}


	/**
	 * Saves the last known rules URL in the persistence under the Configuration DataStore.
	 *
	 * @param rulesURL the last known rules URL that needs to be saved
	 */
	private void saveRulesURLToPersistence(final String rulesURL) {
		LocalStorageService.DataStore configStore = getDataStore();

		if (configStore != null) {
			Log.trace(ConfigurationExtension.LOG_SOURCE, "Saving last known rules URL to persistence - %s", rulesURL);
			configStore.setString(PERSISTED_RULES_URL, rulesURL);
		} else {
			Log.debug(ConfigurationExtension.LOG_SOURCE,
					  "%s (Storage Service), unable to save the last known rules URL to persistence", Log.UNEXPECTED_NULL_VALUE);
		}
	}

	/**
	 * The purpose of the SetAppIDInternalEvent is to refresh the existing with the persisted appId
	 * This method validates the appId for the SetAppIDInternalEvent
	 * It return true, if the persisted appId is same as the internalEvent appId present in the eventData
	 * It return false, if the persisted appId is different from the internalEvent appId present in the eventData
	 *
	 * @param eventData The {@link EventData} associated to the set internal appId event
	 * @param newAppID A {@link String} appId associated with set internal appId event
	 * @return A {@code boolean} indicating if there is a change in appID for the SetAppIDInternalEvent
	 */
	private boolean validateForInternalEventAppIDChange(final EventData eventData, final String newAppID) {
		boolean isInternalEvent = eventData.optBoolean(
									  ConfigurationConstants.EventDataKeys.Configuration.CONFIGURATION_REQUEST_CONTENT_IS_INTERNAL_EVENT, false);

		if (isInternalEvent && (!newAppID.equals(getValidAppID()))) {
			return false;
		}

		return true;
	}


	/**
	 * Returns the configuration datastore
	 *
	 * @return {@code LocalStorageService.DataStore} configuration datastore or null
	 */
	private LocalStorageService.DataStore getDataStore() {

		if (getPlatformServices() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Platform services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		if (getPlatformServices(). getLocalStorageService() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Local Storage services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		return getPlatformServices().getLocalStorageService().getDataStore(DATASTORE_KEY);
	}

	/**
	 * Method to obtain the {@code JsonUtilityService} instance.
	 *
	 * <p>
	 * Returns null if the {@code PlatformServices} is null or the {@code JsonUtilityService} obtained from the
	 * {@code PlatformServices} is null.
	 *
	 * @return {@link JsonUtilityService} instance
	 */
	private JsonUtilityService getJSONUtilityService() {
		if (getPlatformServices() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (Platform services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		if (getPlatformServices().getJsonUtilityService() == null) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "%s (JSON Utility services)", Log.UNEXPECTED_NULL_VALUE);
			return null;
		}

		return getPlatformServices().getJsonUtilityService();
	}

	// ========================================================
	// rules retrieval stuff
	// ========================================================

	/**
	 * Downloads and registers remote rules (asynchronously via getExecutor)
	 *
	 * @param remoteRulesURL the url of remote rules
	 */
	private void downloadRules(final String remoteRulesURL) {

		long currentTimeSec = TimeUtil.getUnixTimeInSeconds();
		Long lastDownloadTimeSec = cachedRulesDownloadTime.get(remoteRulesURL);

		if ((lastDownloadTimeSec != null) && (currentTimeSec - lastDownloadTimeSec < NOT_DOWNLOAD_RULES_WITHIN_TIME_SEC)) {
			Log.debug(ConfigurationExtension.LOG_SOURCE, "Will not download rules from same url in 30 sec. ");
			return;
		}

		cachedRulesDownloadTime.put(remoteRulesURL, currentTimeSec);

		saveRulesURLToPersistence(remoteRulesURL);

		if (StringUtils.isNullOrEmpty(remoteRulesURL)) {
			return;
		}

		final PlatformServices platformServices = getPlatformServices();

		if (platformServices == null) {
			return;
		}

		try {
			final RulesRemoteDownloader remoteDownloader = new RulesRemoteDownloader(
				platformServices.getNetworkService(),
				platformServices.getSystemInfoService(),
				platformServices.getCompressedFileService(),
				remoteRulesURL, RULES_CACHE_FOLDER);
			final File outputFile = remoteDownloader.startDownloadSync();
			onRulesDownloaded(outputFile);
		} catch (final MissingPlatformServicesException e) {
			Log.debug(LOG_SOURCE, "Unable to download remote rules. Exception: %s", e);
		}
	}

	/**
	 * Called when rules have completed downloading
	 *
	 * @param rulesDirectory File object containing the directory that the rules bundle is in
	 */
	private void onRulesDownloaded(final File rulesDirectory) {


		// check if we downloaded a valid file
		if (rulesDirectory == null || !rulesDirectory.isDirectory()) {
			// clear out existing rules
			unregisterAllRules();
			return;
		}

		final String rulesFilePath = rulesDirectory.getPath() + File.separator + RULES_JSON_FILE_NAME;
		final File rulesFile = new File(rulesFilePath);
		final String jsonString = readFromFile(rulesFile);

		// read new object
		final JsonUtilityService.JSONObject rulesJsonObject = getPlatformServices()
				.getJsonUtilityService()
				.createJSONObject(jsonString);

		replaceRulesAndReprocessEvents(parseRulesFromJsonObject(rulesJsonObject));

	}


	/**
	 * Call this method to replace module rules in Event hub, then notify Event hub to reprocess
	 * (cached) custom events with given rules if it's the fist time you call this method.
	 *
	 * @param rules loaded from remote or local files
	 */
	void replaceRulesAndReprocessEvents(final List<Rule> rules) {
		if (this.needToProcessEvents.getAndSet(false)) {
			replaceRulesAndEvaluateEvents(rules, new ReprocessEventsHandler() {
				@Override
				public List<Event> getEvents() {
					return new ArrayList<Event>(cachedEvents);
				}

				@Override
				public void onEventReprocessingComplete() {
					unregisterWildcardListener();
					cachedEvents.clear();
				}
			});
		} else {
			replaceRules(rules);
		}
	}

	/**
	 * Reads a file from disk and returns its contents as {@code String}.
	 *
	 * @param rulesJsonFile the file object to read
	 *
	 * @return the file contents as {@code String}
	 */
	private String readFromFile(final File rulesJsonFile) {
		String json = null;

		if (rulesJsonFile != null) {
			FileInputStream rulesJsonIS = null;

			try {
				rulesJsonIS = new FileInputStream(rulesJsonFile);
				json = StringUtils.streamToString(rulesJsonIS);
			} catch (IOException ex) {
				Log.debug(LOG_SOURCE, "Could not read the rules json file! Exception: (%s)", ex);
			} finally {
				try {
					if (rulesJsonIS != null) {
						rulesJsonIS.close();
					}
				} catch (Exception e) {
					Log.trace(LOG_SOURCE, "Failed to close stream for %s, with Exception: %s", rulesJsonFile, e);
				}
			}
		}

		return json;
	}

	/**
	 * Parses all rules and resulting consequence events from the jsonObject
	 *
	 * @param jsonObject {@code JSONObject} containing the list of rules and consequences
	 *
	 * @return a {@code List} of {@code Rule} objects that were parsed from the input object
	 */
	private List<Rule> parseRulesFromJsonObject(final JsonUtilityService.JSONObject jsonObject) {
		final List<Rule> parsedRules = new ArrayList<Rule>();

		if (jsonObject == null) {
			return parsedRules;
		}

		JsonUtilityService.JSONArray rulesJsonArray;

		try {
			rulesJsonArray = jsonObject.getJSONArray(RULES_JSON_KEY);
		} catch (final JsonException e) {
			Log.debug(LOG_SOURCE, "Unable to parse rules. Exception: (%s)", e);
			return parsedRules;
		}

		// loop through each rule definition
		for (int i = 0; i < rulesJsonArray.length(); i++) {
			try {
				// get individual rule json object
				final JsonUtilityService.JSONObject ruleObject = rulesJsonArray.getJSONObject(i);
				// get rule condition
				final JsonUtilityService.JSONObject ruleConditionJsonObject = ruleObject.getJSONObject(RULES_JSON_CONDITION_KEY);
				final RuleCondition condition = RuleCondition.ruleConditionFromJson(ruleConditionJsonObject);
				// get consequences
				final List<Event> consequences = generateConsequenceEvents(ruleObject.getJSONArray(RULES_JSON_CONSEQUENCES_KEY));

				parsedRules.add(new Rule(condition, consequences));
			} catch (final JsonException e) {
				Log.debug(LOG_SOURCE, "Unable to parse individual rule json. Exception: (%s)", e);
			} catch (final UnsupportedConditionException e) {
				Log.debug(LOG_SOURCE, "Unable to parse individual rule conditions. Exception: (%s)", e);
			} catch (final IllegalArgumentException e) {
				Log.debug(LOG_SOURCE, "Unable to create rule object. Exception: (%s)", e);
			}
		}

		return parsedRules;
	}

	/**
	 * Parses consequence objects from rules definition and converts them into a list of Events
	 *
	 * @param consequenceJsonArray {@code JSONArray} object containing 1 or more rule consequence definitions
	 *
	 * @return a {@code List} of consequence {@code Event} objects.
	 *
	 * @throws JsonException if errors occur during parsing
	 */
	private List<Event> generateConsequenceEvents(final JsonUtilityService.JSONArray consequenceJsonArray) throws
		JsonException {
		final List<Event> parsedEvents = new ArrayList<Event>();

		if (consequenceJsonArray == null) {
			return  parsedEvents;
		}

		for (int i = 0; i < consequenceJsonArray.length(); i++) {
			final RuleConsequence consequence = RuleConsequence.consequenceFromJson(consequenceJsonArray.getJSONObject(i),
												getPlatformServices().getJsonUtilityService());

			if (consequence != null) {
				final Event event = new Event.Builder("Rules Event", EventType.RULES_ENGINE, EventSource.RESPONSE_CONTENT)
				.setData(consequence.generateEventData())
				.build();

				parsedEvents.add(event);
			}
		}

		return parsedEvents;
	}

	private void retrieveCachedRules(final String remoteRulesURL) {

		if (StringUtils.isNullOrEmpty(remoteRulesURL)) {
			return;
		}

		final PlatformServices platformServices = getPlatformServices();

		if (platformServices == null) {
			return;
		}

		try {
			final RulesRemoteDownloader remoteDownloader = new RulesRemoteDownloader(
				platformServices.getNetworkService(),
				platformServices.getSystemInfoService(),
				platformServices.getCompressedFileService(),
				remoteRulesURL, RULES_CACHE_FOLDER);
			final File outputFile = remoteDownloader.getCachedRulesFile();
			onRulesDownloaded(outputFile);
		} catch (final MissingPlatformServicesException e) {
			Log.debug(LOG_SOURCE, "Unable to read cached remote rules. Exception: (%s)", e);
		}
	}
}