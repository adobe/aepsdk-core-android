/* *****************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2018 Adobe
 * All Rights Reserved.
 *
 * NOTICE: All information contained herein is, and remains
 * the property of Adobe and its suppliers, if any. The intellectual
 * and technical concepts contained herein are proprietary to Adobe
 * and its suppliers and are protected by all applicable intellectual
 * property laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe.
 ******************************************************************************/

package com.adobe.marketing.mobile.identity;

import com.adobe.marketing.mobile.Event;
import com.adobe.marketing.mobile.Log;
import com.adobe.marketing.mobile.MobilePrivacyStatus;

import java.io.File;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.Map;

/**
 * Extends {@link HitQueue.IHitProcessor} and aids in the necessary tasks to
 * create and maintain a database to hold requests for the {@link IdentityExtension}
 */
class IdentityHitsDatabase implements HitQueue.IHitProcessor<IdentityHit> {

	private static final String LOG_TAG                    = "IdentityHitsDatabase";
	private static final String IDENTITY_DATABASE_FILENAME = "ADBMobileIdentity.sqlite";
	private static final String TABLE_REQUESTS             = "REQUESTS";

	private final NetworkService networkService;
	private final SystemInfoService systemInfoService;
	private final IdentityExtension parentModule;
	private final IdentityHitSchema identityHitSchema;
	private final HitQueue<IdentityHit, IdentityHitSchema> hitQueue;

	/**
	 * Constructor
	 * <ul>
	 *     <li>Initializes {@link #identityHitSchema}</li>
	 *     <li>Initializes {@link #hitQueue}</li>
	 *     <li>Assigns {@link #parentModule}, {@link #systemInfoService}, and {@link #networkService}</li>
	 *     <li>Resets event number and pair ID for any existing records in the IdentityExtension table</li>
	 * </ul>
	 *
	 * @param parent {@link IdentityExtension} instance that owns this database
	 * @param services {@link PlatformServices} instance used to access {@link SystemInfoService} and {@link NetworkService}
	 */
	IdentityHitsDatabase(final IdentityExtension parent, final PlatformServices services) {
		this(parent, services, null);
	}

	/**
	 * Constructor
	 * <ul>
	 *     <li>Initializes {@link #identityHitSchema}</li>
	 *     <li>Initializes {@link #hitQueue}</li>
	 *     <li>Assigns {@link #parentModule}, {@link #systemInfoService}, and {@link #networkService}</li>
	 *     <li>Resets event number and pair ID for any existing records in the IdentityExtension table</li>
	 * </ul>
	 *
	 * @param parent {@link IdentityExtension} instance that owns this database
	 * @param services {@link PlatformServices} instance used to access {@link SystemInfoService} and {@link NetworkService}
	 * @param hitQueue instance of HitQueue
	 */
	IdentityHitsDatabase(final IdentityExtension parent, final PlatformServices services,
						 final HitQueue<IdentityHit, IdentityHitSchema> hitQueue) {

		this.identityHitSchema = new IdentityHitSchema();
		this.parentModule = parent;
		this.systemInfoService = services.getSystemInfoService();
		this.networkService = services.getNetworkService();

		final File directory = systemInfoService != null ? systemInfoService.getApplicationCacheDir() : null;
		final File dbFilePath = new File(directory, IDENTITY_DATABASE_FILENAME);

		if (hitQueue != null) {
			this.hitQueue = hitQueue;
		} else {
			this.hitQueue = new HitQueue<IdentityHit, IdentityHitSchema>(services, dbFilePath,
					TABLE_REQUESTS, identityHitSchema, this);
		}

		// if this is a new session, the known event number and pair id values have no use, so we should reset them
		resetEventNumberAndPairIdForExistingRequests();
	}


	/**
	 * Process the provided {@link IdentityHit} and returns the network response to the {@link #parentModule}
	 *
	 * Hit processing can fail under the following scenarios:
	 * <ul>
	 *     <li>The {@link IdentityHit#url} value is null</li>
	 *     <li>The {@link com.adobe.marketing.mobile.NetworkService.HttpConnection} generated by the
	 *     {@link NetworkService} is null</li>
	 *     <li>The {@link com.adobe.marketing.mobile.NetworkService.HttpConnection} succeeds with 200, but has no input stream</li>
	 *     <li>The request failed and response code is not one of the {@link NetworkConnectionUtil#recoverableNetworkErrorCodes}</li>
	 * </ul>
	 *
	 * If a valid response comes back from the server and its code is in {@link NetworkConnectionUtil#recoverableNetworkErrorCodes},
	 * the hit will go back into the queue and we will attempt to process it again later
	 *
	 * @param hit {@code IdentityHit} to be processed
	 * @return {@link com.adobe.marketing.mobile.HitQueue.RetryType} indicating whether the hit should be processed again
	 */
	@Override
	public HitQueue.RetryType process(final IdentityHit hit) {

		if (hit.url == null) {
			Log.debug(IdentityExtension.LOG_SOURCE,
					  "IdentityHitsDatabase.process : Unable to process IdentityExtension hit because it does not contain a url.");
			// make sure the parent updates shared state and notifies one-time listeners accordingly
			parentModule.networkResponseLoaded(null, hit.pairId, hit.eventNumber);
			return HitQueue.RetryType.NO;
		}

		Log.debug(IdentityExtension.LOG_SOURCE, "IdentityHitsDatabase.process : Sending request: (%s).", hit.url);
		Map<String, String> requestPropertyMap = NetworkConnectionUtil.getHeaders(hit.configSSL);

		// make the request synchronously
		final NetworkService.HttpConnection connection = networkService.connectUrl(hit.url,
				NetworkService.HttpCommand.GET, null, requestPropertyMap, IdentityConstants.Defaults.TIMEOUT,
				IdentityConstants.Defaults.TIMEOUT);

		if (connection == null) {
			Log.debug(IdentityExtension.LOG_SOURCE,
					  "IdentityHitsDatabase.process : An unknown error occurred during the Identity network call, connection is null. Will not retry.");

			// make sure the parent updates shared state and notifies one-time listeners accordingly
			parentModule.networkResponseLoaded(null, hit.pairId, hit.eventNumber);

			return HitQueue.RetryType.NO;
		}

		if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {

			String networkInputStreamJSONString;
			IdentityResponseObject result = null;

			try {
				networkInputStreamJSONString = NetworkConnectionUtil.readFromInputStream(connection.getInputStream());

				if (parentModule.getPlatformServices() == null) {
					Log.debug(IdentityExtension.LOG_SOURCE,
							  "IdentityHitsDatabase.process : Unable to parse the ECID Service response data because Platform Services are not available.");
					parentModule.networkResponseLoaded(null, hit.pairId, hit.eventNumber);
					return HitQueue.RetryType.NO;
				}

				final JsonUtilityService jsonUtilityService = parentModule.getPlatformServices().getJsonUtilityService();

				if (jsonUtilityService == null) {
					Log.debug(IdentityExtension.LOG_SOURCE,
							  "IdentityHitsDatabase.process : Unable to parse the ECID Service response data because the JSON utility service is not available.");
					parentModule.networkResponseLoaded(null, hit.pairId, hit.eventNumber);
					return HitQueue.RetryType.NO;
				}

				final JsonUtilityService.JSONObject jsonObject = jsonUtilityService.createJSONObject(networkInputStreamJSONString);

				if (jsonObject == null) {
					Log.debug(IdentityExtension.LOG_SOURCE,
							  "IdentityHitsDatabase.process : Unable to parse the ECID Service response data, no response data or invalid JSON format: (%s)",
							  networkInputStreamJSONString);
					parentModule.networkResponseLoaded(null, hit.pairId, hit.eventNumber);
					return HitQueue.RetryType.NO;
				}

				result = createIdentityObjectFromResponseJsonObject(jsonObject);


			} catch (final IOException e) {
				Log.debug(IdentityExtension.LOG_SOURCE,
						  "IdentityHitsDatabase.process : An unknown exception occurred while trying to process the response from the ECID Service: (%s).",
						  e);
			}

			Log.trace(LOG_TAG, "IdentityHitsDatabase.process : ECID Service response data was parsed successfully.");
			parentModule.networkResponseLoaded(result, hit.pairId, hit.eventNumber);
			return HitQueue.RetryType.NO;

		} else if (!NetworkConnectionUtil.recoverableNetworkErrorCodes.contains(connection.getResponseCode())) {

			// unrecoverable error. delete the hit from the database and continue
			Log.debug(LOG_TAG,
					  "IdentityHitsDatabase.process : Discarding ECID Service request because of an un-recoverable network error with response code %d occurred while processing it.",
					  connection.getResponseCode());
			// make sure the parent updates shared state and notifies one-time listeners accordingly
			parentModule.networkResponseLoaded(null, hit.pairId, hit.eventNumber);
			return HitQueue.RetryType.NO;
		} else {
			// recoverable error.  leave the request in the queue, wait for 30 sec, and try again
			Log.debug(LOG_TAG,
					  "IdentityHitsDatabase.process : A recoverable network error occurred with response code %d while processing ECID Service requests.  Will retry in 30 seconds.",
					  connection.getResponseCode());
			return HitQueue.RetryType.YES;
		}
	}

	/**
	 * Attempts to creates a new record in the {@link IdentityHitsDatabase}
	 * If the insert fails, a warning will be logged and the database will be deleted and re-created
	 *
	 * @param url {@link String} representing the URL of the {@link IdentityExtension} request
	 * @param event {@link Event} containing information for this request
	 * @param configSharedState {@link ConfigurationSharedStateIdentity} containing config corresponding to the event
	 * @return true if hit was successfully added to the queue
	 */
	boolean queue(final String url, final Event event, final ConfigurationSharedStateIdentity configSharedState) {
		// kick the work over to the runnable task on the identity executor thread
		IdentityHit identityHit = new IdentityHit();
		identityHit.url = url;
		identityHit.timestamp = event.getTimestampInSeconds();
		identityHit.pairId = event.getResponsePairID();
		identityHit.eventNumber = event.getEventNumber();
		identityHit.configSSL = IdentityConstants.Defaults.DEFAULT_SSL;

		boolean queueResult = this.hitQueue.queue(identityHit);
		Log.debug(LOG_TAG,
				  "IdentityHitsDatabase.queue : Queued an identity sync call with URL: (%s) resulted from the event: (%s).", url,
				  event.getUniqueIdentifier());

		if (configSharedState.privacyStatus == MobilePrivacyStatus.OPT_IN) {
			this.hitQueue.bringOnline();
		}

		return queueResult;
	}

	/**
	 * Signals a {@code MobilePrivacyStatus} change to this {@code HitsDatabase}.
	 * The database performs the following actions based on the new {@link MobilePrivacyStatus}:
	 * <ul>
	 *     <li>{@link MobilePrivacyStatus#OPT_IN} - Brings the {@link HitQueue} online</li>
	 *     <li>{@link MobilePrivacyStatus#OPT_OUT} - Suspends the {@link HitQueue} and deletes all queued hits</li>
	 *     <li>{@link MobilePrivacyStatus#UNKNOWN} - Suspends the {@link HitQueue}</li>
	 * </ul>
	 * @param privacyStatus the new {@link MobilePrivacyStatus}
	 */
	void updatePrivacyStatus(final MobilePrivacyStatus privacyStatus) {
		if (hitQueue == null) {
			Log.trace(LOG_TAG,
					  "updatePrivacyStatus : No Identity hits to process due to Privacy Status change.");
			return;
		}

		switch (privacyStatus) {
			case OPT_IN:
				Log.debug(LOG_TAG,
						  "updatePrivacyStatus : Privacy Status was opted-in, so attempting to send all the queued Identity hits from database.");
				hitQueue.bringOnline();
				break;

			case OPT_OUT:
				Log.debug(LOG_TAG,
						  "updatePrivacyStatus : Privacy Status was opted-out, so all the queued Identity hits were cleared from database.");
				hitQueue.suspend();
				hitQueue.deleteAllHits();
				break;

			case UNKNOWN:
				Log.debug(LOG_TAG,
						  "updatePrivacyStatus : Privacy Status was opt-unknown, suspending the Identity hits processing from database.");
				hitQueue.suspend();
				break;

			default:
				Log.debug(LOG_TAG,
						  "updatePrivacyStatus : Received an unknown Privacy Status value: (%s). ", privacyStatus);
		}

	}


	// ================================================================================================================
	// private methods & classes
	// ================================================================================================================
	/**
	 * Resets {@link IdentityHit#eventNumber} and {@link IdentityHit#pairId} for all records in the
	 * {@link IdentityHitsDatabase}
	 *
	 * The {@link EventHub} does not live cross-session, so {@code pairId} and {@code eventNumber} have no meaning
	 * outside of the session in which they originated
	 *
	 * This method should only be called when the {@code IdentityHitsDatabase} initializes
	 */
	private void resetEventNumberAndPairIdForExistingRequests() {
		Map<String, Object>  updateValues = this.identityHitSchema.generateUpdateValuesForResetEventNumberAndPairId();
		this.hitQueue.updateAllHits(updateValues);
	}

	IdentityResponseObject createIdentityObjectFromResponseJsonObject(final JsonUtilityService.JSONObject jsonObject) {
		IdentityResponseObject result = null;

		if (jsonObject == null) {
			Log.debug(IdentityExtension.LOG_SOURCE,
					  "createIdentityObjectFromResponseJsonObject: Unable to parse identity network response because the JSON object created was null.");
			return result;
		}

		result = new IdentityResponseObject();

		result.blob = jsonObject.optString(IdentityConstants.UrlKeys.BLOB, null);
		result.error = jsonObject.optString(IdentityConstants.UrlKeys.RESPONSE_ERROR, null);
		result.mid = jsonObject.optString(IdentityConstants.UrlKeys.MID, null);

		int hintValue = jsonObject.optInt(IdentityConstants.UrlKeys.HINT, -1);
		result.hint = hintValue == -1 ? null : Integer.toString(hintValue);

		result.ttl = jsonObject.optLong(IdentityConstants.UrlKeys.TTL, IdentityConstants.Defaults.DEFAULT_TTL_VALUE);

		JsonUtilityService.JSONArray optOutJsonArray = jsonObject.optJSONArray(IdentityConstants.UrlKeys.OPT_OUT);

		if (optOutJsonArray != null) {
			ArrayList<String> optOutVector = new ArrayList();

			for (int i = 0; i < optOutJsonArray.length(); i++) {
				try {
					optOutVector.add(optOutJsonArray.getString(i));
				} catch (JsonException e) {
					Log.debug(IdentityExtension.LOG_SOURCE,
							  "createIdentityObjectFromResponseJsonObject : Unable to read opt-out JSON array due to an exception: (%s).", e);
				}
			}

			result.optOutList = optOutVector;
		}

		return result;
	}
}
